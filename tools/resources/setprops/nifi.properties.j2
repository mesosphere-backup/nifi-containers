# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Core Properties #
nifi.flow.configuration.file={{ nifi_flow_configuration_file|default("./conf/flow.xml.gz") }}
nifi.flow.configuration.archive.enabled={{ nifi_flow_configuration_archive_enabled|default("true") }}
nifi.flow.configuration.archive.dir={{ nifi_flow_configuration_archive_dir|default("./conf/archive/") }}
nifi.flow.configuration.archive.max.time={{ nifi_flow_configuration_archive_max_time|default("30 days") }}
nifi.flow.configuration.archive.max.storage={{ nifi_flow_configuration_archive_max_storage|default("500 MB") }}
nifi.flow.configuration.archive.max.count={{ nifi_flow_configuration_archive_max_count }}
nifi.flowcontroller.autoResumeState={{ nifi_flowcontroller_autoresumestate|default("true") }}
nifi.flowcontroller.graceful.shutdown.period={{ nifi_flowcontroller_graceful_shutdown_period|default("10 sec") }}
nifi.flowservice.writedelay.interval={{ nifi_flowservice_writedelay_interval|default("500 ms") }}
nifi.administrative.yield.duration={{ nifi_administrative_yield_duration|default("30 sec") }}
# If a component has no work to do (is "bored"), how long should we wait before checking again for work?
nifi.bored.yield.duration={{ nifi_bored_yield_duration|default("10 millis") }}
nifi.queue.backpressure.count={{ nifi_queue_backpressure_count|default("10000") }}
nifi.queue.backpressure.size={{ nifi_queue_backpressure_size|default("1 GB") }}

nifi.authorizer.configuration.file={{ nifi_authorizer_configuration_file|default("./conf/authorizers.xml") }}
nifi.login.identity.provider.configuration.file={{ nifi_login_identity_provider_configuration_file|default("./conf/login-identity-providers.xml") }}
nifi.templates.directory={{ nifi_templates_directory|default("./conf/templates") }}
nifi.ui.banner.text={{ nifi_ui_banner_text }}
nifi.ui.autorefresh.interval={{ nifi_ui_autorefresh_interval|default("30 sec") }}
nifi.nar.library.directory={{ nifi_nar_library_directory|default("./lib") }}
nifi.nar.library.autoload.directory={{ nifi_nar_library_autoload_directory|default("./extensions") }}
nifi.nar.working.directory={{ nifi_nar_working_directory|default("./work/nar/") }}
nifi.documentation.working.directory={{ nifi_documentation_working_directory|default("./work/docs/components") }}

####################
# State Management #
####################
nifi.state.management.configuration.file={{ nifi_state_management_configuration_file|default("./conf/state-management.xml") }}
# The ID of the local state provider
nifi.state.management.provider.local={{ nifi_state_management_provider_local|default("local-provider") }}
# The ID of the cluster-wide state provider. This will be ignored if NiFi is not clustered but must be populated if running in a cluster.
nifi.state.management.provider.cluster={{ nifi_state_management_provider_cluster|default("zk-provider") }}
# Specifies whether or not this instance of NiFi should run an embedded ZooKeeper server
nifi.state.management.embedded.zookeeper.start={{ nifi_state_management_embedded_zookeeper_start|default("false") }}
# Properties file that provides the ZooKeeper properties to use if <nifi.state.management.embedded.zookeeper.start> is set to true
nifi.state.management.embedded.zookeeper.properties={{ nifi_state_management_embedded_zookeeper_properties|default("./conf/zookeeper.properties") }}


# H2 Settings
nifi.database.directory={{ nifi_database_directory|default("./database_repository") }}
nifi.h2.url.append={{ nifi_h2_url_append|default(";LOCK_TIMEOUT=25000;WRITE_DELAY=0;AUTO_SERVER=FALSE") }}

# FlowFile Repository
nifi.flowfile.repository.implementation={{ nifi_flowfile_repository_implementation|default("org.apache.nifi.controller.repository.WriteAheadFlowFileRepository") }}
nifi.flowfile.repository.wal.implementation={{ nifi_flowfile_repository_wal_implementation|default("org.apache.nifi.wali.SequentialAccessWriteAheadLog") }}
nifi.flowfile.repository.directory={{ nifi_flowfile_repository_directory|default("./flowfile_repository") }}
nifi.flowfile.repository.partitions={{ nifi_flowfile_repository_partitions|default("256") }}
nifi.flowfile.repository.checkpoint.interval={{ nifi_flowfile_repository_checkpoint_interval|default("2 mins") }}
nifi.flowfile.repository.always.sync={{ nifi_flowfile_repository_always_sync|default("false") }}

nifi.swap.manager.implementation={{ nifi_swap_manager_implementation|default("org.apache.nifi.controller.FileSystemSwapManager") }}
nifi.queue.swap.threshold={{ nifi_queue_swap_threshold|default("20000") }}
nifi.swap.in.period={{ nifi_swap_in_period|default("5 sec") }}
nifi.swap.in.threads={{ nifi_swap_in_threads|default("1") }}
nifi.swap.out.period={{ nifi_swap_out_period|default("5 sec") }}
nifi.swap.out.threads={{ nifi_swap_out_threads|default("4") }}

# Content Repository
nifi.content.repository.implementation={{ nifi_content_repository_implementation|default("org.apache.nifi.controller.repository.FileSystemRepository") }}
nifi.content.claim.max.appendable.size={{ nifi_content_claim_max_appendable_size|default("1 MB") }}
nifi.content.claim.max.flow.files={{ nifi_content_claim_max_flow_files|default("100") }}
nifi.content.repository.directory.default={{ nifi_content_repository_directory_default|default("./content_repository") }}
nifi.content.repository.archive.max.retention.period={{ nifi_content_repository_archive_max_retention_period|default("12 hours") }}
nifi.content.repository.archive.max.usage.percentage={{ nifi_content_repository_archive_max_usage_percentage|default("50%") }}
nifi.content.repository.archive.enabled={{ nifi_content_repository_archive_enabled|default("true") }}
nifi.content.repository.always.sync={{ nifi_content_repository_always_sync|default("false") }}
nifi.content.viewer.url={{ nifi_content_viewer_url|default("../nifi-content-viewer/") }}

# Provenance Repository Properties
nifi.provenance.repository.implementation={{ nifi_provenance_repository_implementation|default("org.apache.nifi.provenance.WriteAheadProvenanceRepository") }}
nifi.provenance.repository.debug.frequency={{ nifi_provenance_repository_debug_frequency|default("1_000_000") }}
nifi.provenance.repository.encryption.key.provider.implementation={{ nifi_provenance_repository_encryption_key_provider_implementation }}
nifi.provenance.repository.encryption.key.provider.location={{ nifi_provenance_repository_encryption_key_provider_location }}
nifi.provenance.repository.encryption.key.id={{ nifi_provenance_repository_encryption_key_id }}
nifi.provenance.repository.encryption.key={{ nifi_provenance_repository_encryption_key }}

# Persistent Provenance Repository Properties
nifi.provenance.repository.directory.default={{ nifi_provenance_repository_directory_default|default("./provenance_repository") }}
nifi.provenance.repository.max.storage.time={{ nifi_provenance_repository_max_storage_time|default("24 hours") }}
nifi.provenance.repository.max.storage.size={{ nifi_provenance_repository_max_storage_size|default("1 GB") }}
nifi.provenance.repository.rollover.time={{ nifi_provenance_repository_rollover_time|default("30 secs") }}
nifi.provenance.repository.rollover.size={{ nifi_provenance_repository_rollover_size|default("100 MB") }}
nifi.provenance.repository.query.threads={{ nifi_provenance_repository_query_threads|default("2") }}
nifi.provenance.repository.index.threads={{ nifi_provenance_repository_index_threads|default("2") }}
nifi.provenance.repository.compress.on.rollover={{ nifi_provenance_repository_compress_on_rollover|default("true") }}
nifi.provenance.repository.always.sync={{ nifi_provenance_repository_always_sync|default("false") }}
# Comma-separated list of fields. Fields that are not indexed will not be searchable. Valid fields are:
# EventType, FlowFileUUID, Filename, TransitURI, ProcessorID, AlternateIdentifierURI, Relationship, Details
nifi.provenance.repository.indexed.fields={{ nifi_provenance_repository_indexed_fields|default("EventType, FlowFileUUID, Filename, ProcessorID, Relationship") }}
# FlowFile Attributes that should be indexed and made searchable.  Some examples to consider are filename, uuid, mime.type
nifi.provenance.repository.indexed.attributes={{ nifi_provenance_repository_indexed_attributes }}
# Large values for the shard size will result in more Java heap usage when searching the Provenance Repository
# but should provide better performance
nifi.provenance.repository.index.shard.size={{ nifi_provenance_repository_index_shard_size|default("500 MB") }}
# Indicates the maximum length that a FlowFile attribute can be when retrieving a Provenance Event from
# the repository. If the length of any attribute exceeds this value, it will be truncated when the event is retrieved.
nifi.provenance.repository.max.attribute.length={{ nifi_provenance_repository_max_attribute_length|default("65536") }}
nifi.provenance.repository.concurrent.merge.threads={{ nifi_provenance_repository_concurrent_merge_threads|default("2") }}


# Volatile Provenance Respository Properties
nifi.provenance.repository.buffer.size={{ nifi_provenance_repository_buffer_size|default("100000") }}

# Component Status Repository
nifi.components.status.repository.implementation={{ nifi_components_status_repository_implementation|default("org.apache.nifi.controller.status.history.VolatileComponentStatusRepository") }}
nifi.components.status.repository.buffer.size={{ nifi_components_status_repository_buffer_size|default("1440") }}
nifi.components.status.snapshot.frequency={{ nifi_components_status_snapshot_frequency|default("1 min") }}

# Site to Site properties
nifi.remote.input.host={{ nifi_remote_input_host }}
nifi.remote.input.secure={{ nifi_remote_input_secure|default("false") }}
nifi.remote.input.socket.port={{ nifi_remote_input_socket_port }}
nifi.remote.input.http.enabled={{ nifi_remote_input_http_enabled|default("true") }}
nifi.remote.input.http.transaction.ttl={{ nifi_remote_input_http_transaction_ttl|default("30 sec") }}
nifi.remote.contents.cache.expiration={{ nifi_remote_contents_cache_expiration|default("30 secs") }}

# web properties #
nifi.web.war.directory={{ nifi_web_war_directory|default("./lib") }}
nifi.web.http.host={{ nifi_web_http_host|default("") }}
nifi.web.http.port={{ nifi_web_http_port|default("") }}
nifi.web.http.network.interface.default={{ nifi_web_http_network_interface_default }}
nifi.web.https.host={{ nifi_web_https_host|default("") }}
nifi.web.https.port={{ nifi_web_https_port|default("") }}
nifi.web.https.network.interface.default={{ nifi_web_https_network_interface_default }}
nifi.web.jetty.working.directory={{ nifi_web_jetty_working_directory|default("./work/jetty") }}
nifi.web.jetty.threads={{ nifi_web_jetty_threads|default("200") }}
nifi.web.max.header.size={{ nifi_web_max_header_size|default("16 KB") }}
nifi.web.proxy.context.path={{ nifi_web_proxy_context_path }}
nifi.web.proxy.host={{ nifi_web_proxy_host }}

# security properties #
nifi.sensitive.props.key={{ nifi_sensitive_props_key }}
nifi.sensitive.props.key.protected={{ nifi_sensitive_props_key_protected }}
nifi.sensitive.props.algorithm={{ nifi_sensitive_props_algorithm|default("PBEWITHMD5AND256BITAES-CBC-OPENSSL") }}
nifi.sensitive.props.provider={{ nifi_sensitive_props_provider|default("BC") }}
nifi.sensitive.props.additional.keys={{ nifi_sensitive_props_additional_keys }}

nifi.security.keystore={{ nifi_security_keystore }}
nifi.security.keystoreType={{ nifi_security_keystoretype }}
nifi.security.keystorePasswd={{ nifi_security_keystorepasswd }}
nifi.security.keyPasswd={{ nifi_security_keypasswd }}
nifi.security.truststore={{ nifi_security_truststore }}
nifi.security.truststoreType={{ nifi_security_truststoretype }}
nifi.security.truststorePasswd={{ nifi_security_truststorepasswd }}
nifi.security.user.authorizer={{ nifi_security_user_authorizer|default("managed-authorizer") }}
nifi.security.user.login.identity.provider={{ nifi_security_user_login_identity_provider }}
nifi.security.ocsp.responder.url={{ nifi_security_ocsp_responder_url }}
nifi.security.ocsp.responder.certificate={{ nifi_security_ocsp_responder_certificate }}

# OpenId Connect SSO Properties #
nifi.security.user.oidc.discovery.url={{ nifi_security_user_oidc_discovery_url }}
nifi.security.user.oidc.connect.timeout={{ nifi_security_user_oidc_connect_timeout|default("5 secs") }}
nifi.security.user.oidc.read.timeout={{ nifi_security_user_oidc_read_timeout|default("5 secs") }}
nifi.security.user.oidc.client.id={{ nifi_security_user_oidc_client_id }}
nifi.security.user.oidc.client.secret={{ nifi_security_user_oidc_client_secret }}
nifi.security.user.oidc.preferred.jwsalgorithm={{ nifi_security_user_oidc_preferred_jwsalgorithm }}

# Apache Knox SSO Properties #
nifi.security.user.knox.url={{ nifi_security_user_knox_url }}
nifi.security.user.knox.publicKey={{ nifi_security_user_knox_publickey }}
nifi.security.user.knox.cookieName={{ nifi_security_user_knox_cookiename|default("hadoop-jwt") }}
nifi.security.user.knox.audiences={{ nifi_security_user_knox_audiences }}

# Identity Mapping Properties #
# These properties allow normalizing user identities such that identities coming from different identity providers
# (certificates, LDAP, Kerberos) can be treated the same internally in NiFi. The following example demonstrates normalizing
# DNs from certificates and principals from Kerberos into a common identity string:
#
# nifi.security.identity.mapping.pattern.dn=^CN=(.*?), OU=(.*?), O=(.*?), L=(.*?), ST=(.*?), C=(.*?)$
# nifi.security.identity.mapping.value.dn=$1@$2
# nifi.security.identity.mapping.transform.dn=NONE
# nifi.security.identity.mapping.pattern.kerb=^(.*?)/instance@(.*?)$
# nifi.security.identity.mapping.value.kerb=$1@$2
# nifi.security.identity.mapping.transform.kerb=UPPER

# Group Mapping Properties #
# These properties allow normalizing group names coming from external sources like LDAP. The following example
# lowercases any group name.
#
# nifi.security.group.mapping.pattern.anygroup=^(.*)$
# nifi.security.group.mapping.value.anygroup=$1
# nifi.security.group.mapping.transform.anygroup=LOWER

# cluster common properties (all nodes must have same values) #
nifi.cluster.protocol.heartbeat.interval={{ nifi_cluster_protocol_heartbeat_interval|default("5 sec") }}
nifi.cluster.protocol.is.secure={{ nifi_cluster_protocol_is_secure|default("false") }}

# cluster node properties (only configure for cluster nodes) #
nifi.cluster.is.node={{ nifi_cluster_is_node|default("false") }}
nifi.cluster.node.address={{ nifi_cluster_node_address }}
nifi.cluster.node.protocol.port={{ nifi_cluster_node_protocol_port }}
nifi.cluster.node.protocol.threads={{ nifi_cluster_node_protocol_threads|default("10") }}
nifi.cluster.node.protocol.max.threads={{ nifi_cluster_node_protocol_max_threads|default("50") }}
nifi.cluster.node.event.history.size={{ nifi_cluster_node_event_history_size|default("25") }}
nifi.cluster.node.connection.timeout={{ nifi_cluster_node_connection_timeout|default("5 sec") }}
nifi.cluster.node.read.timeout={{ nifi_cluster_node_read_timeout|default("5 sec") }}
nifi.cluster.node.max.concurrent.requests={{ nifi_cluster_node_max_concurrent_requests|default("100") }}
nifi.cluster.firewall.file={{ nifi_cluster_firewall_file }}
nifi.cluster.flow.election.max.wait.time={{ nifi_cluster_flow_election_max_wait_time|default("5 mins") }}
nifi.cluster.flow.election.max.candidates={{ nifi_cluster_flow_election_max_candidates }}

# cluster load balancing properties #
nifi.cluster.load.balance.host={{ nifi_cluster_load_balance_host }}
nifi.cluster.load.balance.port={{ nifi_cluster_load_balance_port|default("6342") }}
nifi.cluster.load.balance.connections.per.node={{ nifi_cluster_load_balance_connections_per_node|default("4") }}
nifi.cluster.load.balance.max.thread.count={{ nifi_cluster_load_balance_max_thread_count|default("8") }}
nifi.cluster.load.balance.comms.timeout={{ nifi_cluster_load_balance_comms_timeout|default("30 sec") }}

# zookeeper properties, used for cluster management #
nifi.zookeeper.connect.string={{ nifi_zookeeper_connect_string }}
nifi.zookeeper.connect.timeout={{ nifi_zookeeper_connect_timeout|default("3 secs") }}
nifi.zookeeper.session.timeout={{ nifi_zookeeper_session_timeout|default("3 secs") }}
nifi.zookeeper.root.node={{ nifi_zookeeper_root_node|default("/nifi") }}

# Zookeeper properties for the authentication scheme used when creating acls on znodes used for cluster management
# Values supported for nifi.zookeeper.auth.type are "default", which will apply world/anyone rights on znodes
# and "sasl" which will give rights to the sasl/kerberos identity used to authenticate the nifi node
# The identity is determined using the value in nifi.kerberos.service.principal and the removeHostFromPrincipal
# and removeRealmFromPrincipal values (which should align with the kerberos.removeHostFromPrincipal and kerberos.removeRealmFromPrincipal
# values configured on the zookeeper server).
nifi.zookeeper.auth.type={{ nifi_zookeeper_auth_type }}
nifi.zookeeper.kerberos.removeHostFromPrincipal={{ nifi_zookeeper_kerberos_removehostfromprincipal }}
nifi.zookeeper.kerberos.removeRealmFromPrincipal={{ nifi_zookeeper_kerberos_removerealmfromprincipal }}

# kerberos #
nifi.kerberos.krb5.file={{ nifi_kerberos_krb5_file }}

# kerberos service principal #
nifi.kerberos.service.principal={{ nifi_kerberos_service_principal }}
nifi.kerberos.service.keytab.location={{ nifi_kerberos_service_keytab_location }}

# kerberos spnego principal #
nifi.kerberos.spnego.principal={{ nifi_kerberos_spnego_principal }}
nifi.kerberos.spnego.keytab.location={{ nifi_kerberos_spnego_keytab_location }}
nifi.kerberos.spnego.authentication.expiration={{ nifi_kerberos_spnego_authentication_expiration|default("12 hours") }}

# external properties files for variable registry
# supports a comma delimited list of file locations
nifi.variable.registry.properties={{ nifi_variable_registry_properties }}
